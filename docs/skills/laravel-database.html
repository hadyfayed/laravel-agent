---
layout: page
title: laravel-database
description: Optimize queries, fix N+1 issues, design schemas with indexes
nav_active: Skills
back_url: /skills.html
back_text: All Skills
---

<div class="mb-8">
    <div class="flex items-center gap-4 mb-4">
        <div class="w-12 h-12 rounded-[var(--radius)] bg-gradient-to-br from-amber-500 to-amber-600 flex items-center justify-center">
            <svg class="w-6 h-6 text-white" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 7v10c0 2.21 3.582 4 8 4s8-1.79 8-4V7M4 7c0 2.21 3.582 4 8 4s8-1.79 8-4M4 7c0-2.21 3.582-4 8-4s8 1.79 8 4"/></svg>
        </div>
        <div>
            <h1 class="text-3xl font-bold">laravel-database</h1>
            <p class="text-muted-foreground">Auto-invoked skill</p>
        </div>
    </div>
    <p class="text-xl text-muted-foreground">Optimize queries, fix N+1 issues, design schemas with indexes</p>
</div>

<div class="prose prose-neutral dark:prose-invert max-w-none">
    <h2>Trigger Keywords</h2>
    <p>This skill automatically activates when Claude detects these keywords:</p>
    <div class="flex flex-wrap gap-2 not-prose mb-6">
        <span class="trigger-tag">migration</span>
        <span class="trigger-tag">query</span>
        <span class="trigger-tag">N+1</span>
        <span class="trigger-tag">Big O</span>
        <span class="trigger-tag">O(n)</span>
        <span class="trigger-tag">complexity</span>
        <span class="trigger-tag">nested loop</span>
        <span class="trigger-tag">eloquent</span>
        <span class="trigger-tag">index</span>
        <span class="trigger-tag">database</span>
    </div>

    <h2>Overview</h2>
    <p>The <strong>laravel-database</strong> skill provides expertise for database design, query optimization, and Eloquent best practices. It helps identify and fix N+1 problems, design efficient schemas, and write performant queries.</p>

    <h2>What This Skill Provides</h2>
    <ul>
        <li><strong>Schema Design</strong> - Proper column types, indexes, foreign keys</li>
        <li><strong>N+1 Detection</strong> - Identify and fix eager loading issues</li>
        <li><strong>Big O Fixes</strong> - Detect O(n²) patterns and fix with O(1) lookups</li>
        <li><strong>Query Optimization</strong> - Efficient queries with proper indexing</li>
        <li><strong>Migrations</strong> - Safe, reversible database changes</li>
        <li><strong>Eloquent Patterns</strong> - Scopes, accessors, relationships</li>
        <li><strong>Raw Queries</strong> - When and how to use raw SQL safely</li>
    </ul>

    <h2>Example Conversations</h2>
    <pre class="language-bash"><code class="language-bash"># Fixing N+1 issues
"My page is making 100 queries to load 10 posts with their authors"

# Schema design
"Design a database schema for a multi-tenant e-commerce platform"

# Query optimization
"This query is slow - how can I optimize it?"

# Migration safety
"How do I add a column to a table with millions of rows without downtime?"</code></pre>

    <h2>N+1 Problem & Solution</h2>
    <pre class="language-php"><code class="language-php">// BAD: N+1 queries (1 + N queries)
$posts = Post::all();
foreach ($posts as $post) {
    echo $post->author->name; // Query for each post!
}

// GOOD: Eager loading (2 queries total)
$posts = Post::with('author')->get();
foreach ($posts as $post) {
    echo $post->author->name; // No additional query
}

// BETTER: Eager load nested relationships
$posts = Post::with(['author', 'comments.user'])->get();

// BEST: Constrain eager loads
$posts = Post::with(['comments' => function ($query) {
    $query->where('approved', true)->latest()->limit(5);
}])->get();</code></pre>

    <h2>Big O Complexity Issues</h2>
    <p>Big O complexity issues cause exponential slowdowns as data grows. Detect and fix O(n²) patterns.</p>
    <pre class="language-php"><code class="language-php">// BAD: O(n²) - Nested loops comparing all items
$users = User::all();
$orders = Order::all();
foreach ($users as $user) {
    foreach ($orders as $order) {
        if ($order->user_id === $user->id) {
            // Process - runs n×m times!
        }
    }
}

// GOOD: O(n) - Eager load relationships
$users = User::with('orders')->get();
foreach ($users as $user) {
    foreach ($user->orders as $order) {
        // Process - each order accessed once
    }
}

// GOOD: O(n) - Use groupBy for O(1) lookups
$ordersByUser = Order::all()->groupBy('user_id');
foreach ($users as $user) {
    $userOrders = $ordersByUser->get($user->id, collect());
}

// BAD: O(n²) - contains() is O(n), called n times
$existingEmails = User::pluck('email');
foreach ($newUsers as $userData) {
    if (!$existingEmails->contains($userData['email'])) {
        User::create($userData);
    }
}

// GOOD: O(n) - flip() for O(1) has() lookups
$existingEmails = User::pluck('email')->flip();
foreach ($newUsers as $userData) {
    if (!$existingEmails->has($userData['email'])) {
        User::create($userData);
    }
}</code></pre>

    <div class="overflow-x-auto not-prose mb-6">
        <table class="w-full text-sm">
            <thead>
                <tr class="border-b border-border">
                    <th class="text-left py-3 px-4 font-medium">Pattern</th>
                    <th class="text-left py-3 px-4 font-medium">Bad</th>
                    <th class="text-left py-3 px-4 font-medium">Good</th>
                </tr>
            </thead>
            <tbody>
                <tr class="border-b border-border">
                    <td class="py-3 px-4">Nested loops</td>
                    <td class="py-3 px-4">O(n²)</td>
                    <td class="py-3 px-4">Eager load / keyBy → O(n)</td>
                </tr>
                <tr class="border-b border-border">
                    <td class="py-3 px-4">In-loop queries</td>
                    <td class="py-3 px-4">O(n) queries</td>
                    <td class="py-3 px-4">Batch query → O(1) queries</td>
                </tr>
                <tr class="border-b border-border">
                    <td class="py-3 px-4">contains() in loop</td>
                    <td class="py-3 px-4">O(n²)</td>
                    <td class="py-3 px-4">flip()/has() → O(n)</td>
                </tr>
                <tr class="border-b border-border">
                    <td class="py-3 px-4">filter() in loop</td>
                    <td class="py-3 px-4">O(n×m)</td>
                    <td class="py-3 px-4">groupBy() → O(n+m)</td>
                </tr>
            </tbody>
        </table>
    </div>

    <h2>Index Strategies</h2>
    <div class="overflow-x-auto not-prose">
        <table class="w-full text-sm">
            <thead>
                <tr class="border-b border-border">
                    <th class="text-left py-3 px-4 font-medium">Index Type</th>
                    <th class="text-left py-3 px-4 font-medium">When to Use</th>
                </tr>
            </thead>
            <tbody>
                <tr class="border-b border-border">
                    <td class="py-3 px-4"><code>$table->index('column')</code></td>
                    <td class="py-3 px-4">Columns in WHERE, ORDER BY, JOIN</td>
                </tr>
                <tr class="border-b border-border">
                    <td class="py-3 px-4"><code>$table->unique('email')</code></td>
                    <td class="py-3 px-4">Columns that must be unique</td>
                </tr>
                <tr class="border-b border-border">
                    <td class="py-3 px-4"><code>$table->index(['a', 'b'])</code></td>
                    <td class="py-3 px-4">Columns frequently queried together</td>
                </tr>
                <tr class="border-b border-border">
                    <td class="py-3 px-4"><code>$table->fullText('content')</code></td>
                    <td class="py-3 px-4">Text search columns</td>
                </tr>
            </tbody>
        </table>
    </div>

    <h2>Migration Best Practices</h2>
    <pre class="language-php"><code class="language-php">// Safe column addition (nullable first, then backfill)
public function up()
{
    Schema::table('users', function (Blueprint $table) {
        $table->string('timezone')->nullable()->after('email');
    });

    // Backfill in chunks to avoid memory issues
    User::query()->chunk(1000, function ($users) {
        foreach ($users as $user) {
            $user->update(['timezone' => 'UTC']);
        }
    });
}

// Safe column removal (make nullable first in separate deploy)
public function up()
{
    Schema::table('users', function (Blueprint $table) {
        $table->dropColumn('legacy_field');
    });
}</code></pre>

    <h2>Common Pitfalls</h2>
    <pre class="language-php"><code class="language-php">// 1. N+1 Queries - Always eager load relationships
// BAD
$posts = Post::all();
foreach ($posts as $post) {
    echo $post-&gt;author-&gt;name; // N+1!
}

// GOOD
$posts = Post::with('author')-&gt;get();

// 2. Missing Indexes - Add indexes for WHERE and ORDER BY
Schema::table('orders', function (Blueprint $table) {
    $table-&gt;index(['user_id', 'created_at']);
    $table-&gt;index('status');
});

// 3. SELECT * - Only select needed columns
// BAD
$users = User::all();

// GOOD
$users = User::select(['id', 'name', 'email'])-&gt;get();

// 4. No Chunking - Use chunk() for large datasets
User::chunk(1000, function ($users) {
    foreach ($users as $user) {
        // Process
    }
});

// 5. No Foreign Keys - Always use constraints
$table-&gt;foreignId('user_id')-&gt;constrained()-&gt;cascadeOnDelete();

// 6. No Transactions - Wrap related operations
DB::transaction(function () {
    $order = Order::create([...]);
    $order-&gt;items()-&gt;createMany([...]);
});</code></pre>

    <h2>Package Integration</h2>
    <ul>
        <li><strong>beyondcode/laravel-query-detector</strong> - N+1 detection</li>
        <li><strong>barryvdh/laravel-debugbar</strong> - Query profiling</li>
        <li><strong>spatie/laravel-query-builder</strong> - API query building</li>
    </ul>

    <h2>Best Practices</h2>
    <ul>
        <li>Design indexes based on actual queries</li>
        <li>Use foreign key constraints</li>
        <li>Monitor slow queries in production</li>
        <li>Use database transactions for related operations</li>
        <li>Prevent lazy loading in development: <code>Model::preventLazyLoading(!app()->isProduction())</code></li>
    </ul>

    <h2>Query Debugging</h2>
    <pre class="language-php"><code class="language-php">// Enable query log
DB::enableQueryLog();

// Run your code
$posts = Post::with('author')->get();

// Dump queries
dd(DB::getQueryLog());

// Or use Laravel Debugbar / Telescope in development</code></pre>

    <h2>Related Commands</h2>
    <ul>
        <li><a href="{{ '/commands/db-optimize.html' | relative_url }}" class="text-primary hover:underline">/laravel-agent:db:optimize</a> - Analyze and optimize queries</li>
        <li><a href="{{ '/commands/db-diagram.html' | relative_url }}" class="text-primary hover:underline">/laravel-agent:db:diagram</a> - Generate schema diagrams</li>
    </ul>

    <h2>Related Agent</h2>
    <ul>
        <li><a href="{{ '/agents/laravel-database.html' | relative_url }}" class="text-primary hover:underline">laravel-database</a> - Database optimization specialist</li>
    </ul>
</div>
